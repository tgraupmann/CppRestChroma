/**
 * Razer REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "ChromaSdkInput.h"

namespace ChromaPackage {
namespace Model {

ChromaSdkInput::ChromaSdkInput()
{
    m_Title = U("");
    m_TitleIsSet = false;
    m_Description = U("");
    m_DescriptionIsSet = false;
    m_AuthorIsSet = false;
    m_Device_supportedIsSet = false;
    m_Category = U("");
    m_CategoryIsSet = false;
    
}

ChromaSdkInput::~ChromaSdkInput()
{
}

void ChromaSdkInput::validate()
{
    // TODO: implement validation
}

web::json::value ChromaSdkInput::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_TitleIsSet)
    {
        val[U("title")] = ModelBase::toJson(m_Title);
    }
    if(m_DescriptionIsSet)
    {
        val[U("description")] = ModelBase::toJson(m_Description);
    }
    if(m_AuthorIsSet)
    {
        val[U("author")] = ModelBase::toJson(m_Author);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Device_supported )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val[U("device_supported")] = web::json::value::array(jsonArray);
        }
    }
    if(m_CategoryIsSet)
    {
        val[U("category")] = ModelBase::toJson(m_Category);
    }
    

    return val;
}

void ChromaSdkInput::fromJson(web::json::value& val)
{
    if(val.has_field(U("title")))
    {
        setTitle(ModelBase::stringFromJson(val[U("title")]));
        
    }
    if(val.has_field(U("description")))
    {
        setDescription(ModelBase::stringFromJson(val[U("description")]));
        
    }
    if(val.has_field(U("author")))
    {
        if(!val[U("author")].is_null())
        {
            std::shared_ptr<ChromaSdkInput_author> newItem(new ChromaSdkInput_author());
            newItem->fromJson(val[U("author")]);
            setAuthor( newItem );
        }
        
    }
    {
        m_Device_supported.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("device_supported")))
        {
        for( auto& item : val[U("device_supported")].as_array() )
        {
            m_Device_supported.push_back(ModelBase::stringFromJson(item));
            
        }
        }
    }
    if(val.has_field(U("category")))
    {
        setCategory(ModelBase::stringFromJson(val[U("category")]));
        
    }
    
}

void ChromaSdkInput::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(m_TitleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("title"), m_Title));
        
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("description"), m_Description));
        
    }
    if(m_AuthorIsSet)
    {
        if (m_Author.get())
        {
            m_Author->toMultipart(multipart, U("author."));
        }
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Device_supported )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("device_supported"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_CategoryIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("category"), m_Category));
        
    }
    
}

void ChromaSdkInput::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(multipart->hasContent(U("title")))
    {
        setTitle(ModelBase::stringFromHttpContent(multipart->getContent(U("title"))));
        
    }
    if(multipart->hasContent(U("description")))
    {
        setDescription(ModelBase::stringFromHttpContent(multipart->getContent(U("description"))));
        
    }
    if(multipart->hasContent(U("author")))
    {
        if(multipart->hasContent(U("author")))
        {
            std::shared_ptr<ChromaSdkInput_author> newItem(new ChromaSdkInput_author());
            newItem->fromMultiPart(multipart, U("author."));
            setAuthor( newItem );
        }
        
    }
    {
        m_Device_supported.clear();
        if(multipart->hasContent(U("device_supported")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("device_supported"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_Device_supported.push_back(ModelBase::stringFromJson(item));
            
        }
        }
    }
    if(multipart->hasContent(U("category")))
    {
        setCategory(ModelBase::stringFromHttpContent(multipart->getContent(U("category"))));
        
    }
    
}


utility::string_t ChromaSdkInput::getTitle() const
{
    return m_Title;
}
void ChromaSdkInput::setTitle(utility::string_t value)
{
    m_Title = value;
    m_TitleIsSet = true;
}
bool ChromaSdkInput::titleIsSet() const
{
    return m_TitleIsSet;
}
void ChromaSdkInput::unsetTitle()
{
    m_TitleIsSet = false;
}
utility::string_t ChromaSdkInput::getDescription() const
{
    return m_Description;
}
void ChromaSdkInput::setDescription(utility::string_t value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}
bool ChromaSdkInput::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}
void ChromaSdkInput::unsetDescription()
{
    m_DescriptionIsSet = false;
}
std::shared_ptr<ChromaSdkInput_author> ChromaSdkInput::getAuthor() const
{
    return m_Author;
}
void ChromaSdkInput::setAuthor(std::shared_ptr<ChromaSdkInput_author> value)
{
    m_Author = value;
    m_AuthorIsSet = true;
}
bool ChromaSdkInput::authorIsSet() const
{
    return m_AuthorIsSet;
}
void ChromaSdkInput::unsetAuthor()
{
    m_AuthorIsSet = false;
}
std::vector<utility::string_t>& ChromaSdkInput::getDeviceSupported()
{
    return m_Device_supported;
}
bool ChromaSdkInput::device_supportedIsSet() const
{
    return m_Device_supportedIsSet;
}
void ChromaSdkInput::unsetDevice_supported()
{
    m_Device_supportedIsSet = false;
}
utility::string_t ChromaSdkInput::getCategory() const
{
    return m_Category;
}
void ChromaSdkInput::setCategory(utility::string_t value)
{
    m_Category = value;
    m_CategoryIsSet = true;
}
bool ChromaSdkInput::categoryIsSet() const
{
    return m_CategoryIsSet;
}
void ChromaSdkInput::unsetCategory()
{
    m_CategoryIsSet = false;
}

}
}

